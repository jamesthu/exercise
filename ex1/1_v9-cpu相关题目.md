###1、v9-cpu指令，关键变量描述不够或错误的地方：
	* a: a寄存器
	* b: b寄存器
	* c: c寄存器
	* f: f浮点寄存器
	* g: g浮点寄存器
	* ir:　指令寄存器
	* xpc: pc在host内存中的值
	* fpc: pc在host内存中所在页的下一页的起始地址值
	* tpc: pc在host内存中所在页的起始地址值
	* xsp: sp在host内存中的值
	* tsp: sp在host内存中所在页的起始地址值
	* fsp: 辅助判断是否要经过tr/tw的分析
	* ssp: 核心态的栈指针
	* usp: 用户态的栈指针
	* cycle: 一个指令周期
	* xcycle: 一个时钟周期
	* timer: 计数器，用于时钟中断
	* timeout: 当时钟计时超过timeout时，会触发时钟中断 
	* detla: 每次时钟周期内timer的偏移量，为一固定值4096

###2、在v9-cpu中如何实现时钟中断：
    	CPU内部存在一个timer寄存器，在指令执行的每一个时钟周期内增加一个detla大小的值，当timer大于timeout时，如果中断使能开，将会进入时钟中断，同时timer清零。
    
###3、在v9-cpu中的跳转相关操作是如何实现的：
		首先将xcycle与xpc修改成跳转至后的xcycle与xpc；然后判断pc超出所在页，若超出转到fixpc；最后跳转至next。
		
###4、在v9-cpu中如何设计相应指令，可有效实现函数调用与返回：
		在函数被调用时，先将参数压住栈内，并保存各个寄存器的值，在函数返回时对各个寄存器及栈指针进行恢复。
		
###5、在v9-cpu中如何完成一次内存地址的读写的：
		首先查看页表tr中是否存在虚页号的位置，如果有，则直接将物理页返回；反之没有则在rlook、wlook函数中查看，此时如果存在虚页映射（判断了paging），则需要首先根据访存地址的高10位查看并调用setpage()对tr、tw进行修改即可，否则直接映射，返回即可。
###6、在v9-cpu中如何实现分页机制：
		虚拟地址前十位对应着一个Page Table,最后十二位是页的偏移，中间十位对应着Page Table中的一项；然后从页表中得到物理页号后，加上虚拟地址的后十二位即可得到真实的访问地址。
